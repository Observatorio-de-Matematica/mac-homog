/* matrix implemented by Lisp array */
amatd (a) :=
    a [0];

amatget (a, i, j) := (
    mode_declare (i, fixnum, j, fixnum),
    block (
        [d],
        d : amatd (a),
        d [i, j]
    )
);

amatset (a, i, j, x) := (
    mode_declare (i, fixnum, j, fixnum),
    block (
        [d],
        d : amatd (a),
        d [i, j] : x
    )
);

amatr (a) :=
    a [1];

mode_declare (function (amatr), fixnum);

amatc (a) :=
    a [2];

mode_declare (function (amatc), fixnum);

amattruncr (a, r) :=
    if r > amatr (a) then error ("amattruncr: too many rows", r)
    else a [1] : r;

mode_declare (function (amattruncr), fixnum);

amattruncc (a, c) :=
    if c > amatc (a) then error ("amattruncc: too many columns", c)
    else a [2] : c;

mode_declare (function (amattruncc), fixnum);

newamat (r, c) := (
    mode_declare (r, fixnum, c, fixnum),
    block (
        [a],
        a : make_array ('any, 3),
        a [0] : make_array ('any, r, c),
        a [1] : r,
        a [2] : c,
        a
    )
);

copyamat (a) :=
    block (
        [a2],
        a2 : newamat (amatr (a), amatc (a)),
        fillarray (amatd (a2), amatd (a)),
        a2
    );

mat2amat (m) :=
    block (
        [r, c, a],
        mode_declare (r, fixnum, c, fixnum),
        r : length (m),
        if r = 0 then c : 0
        else c : length (first (m)),
        a : newamat (r, c),
        fillarray (amatd (a), flatten (args (m))),
        a
    );

amat2mat (a) :=
    if amatr (a) = 0 then
        matrix ()
    elseif amatc (a) = 0 then
        apply ('matrix, makelist ([], amatr (a)))
    else
        genmatrix (
            lambda ([i, j], amatget (a, i - 1, j - 1)),
            amatr (a), amatc (a)
        );

/* gcd which returns [g, u, v, x0, y0], where
   g = gcd (x, y)
   u * x + v * y = g
   x0 * g = x, y0 * g = y
   w = the main variable */
eval_when (translate, declare_translated (gcdex));

gcd2 (x, y, w) :=
    block (
        [g, u, v, x0, y0],
        [u, v, g] : ratsimp (gcdex (x, y, w)),
        if g = 0 then (
            x0 : 1,
            y0 : 0
        ) else (
            x0 : ratsimp (x / g),
            y0 : ratsimp (y / g)
        ),
        [g, u, v, x0, y0]
    );

/* lcm */
lcm2 (x, y, w) :=
    block (
        [g, u, v],
        [u, v, g] : ratsimp (gcdex (x, y, w)),
        if g = 0 then 0
        else ratsimp (x * y / g)
    );

/* Gauss elimination with "gcd pivoting" */
aelim_ctx (a) :=
    make_array ('fixnum, 1 + min (amatr (a), amatc (a)));

aelim (a, w, ctx) := (
    mode_declare (completearray (ctx), fixnum),
    block (
        [ip, p, q, x, y, g, u, v, x0, y0],
        mode_declare (ip, fixnum),
        ip : 0,
        for jp : 0 while ip < amatr (a) and jp < amatc (a) do (
            for i : ip + 1 while i < amatr (a) do (
                p : amatget (a, ip, jp),
                q : amatget (a, i, jp),
                if q # 0 then (
                    [g, u, v, x0, y0] : gcd2 (p, q, w),
                    for j : jp while j < amatc (a) do (
                        x : amatget (a, ip, j),
                        y : amatget (a, i, j),
                        amatset (a, ip, j, ratsimp (u * x + v * y)),
                        amatset (a, i, j, ratsimp (- y0 * x + x0 * y))
                    )
                )
            ),
            if amatget (a, ip, jp) # 0 then (
                ctx [ip] : jp,
                ip : ip + 1
            )
        ),
        ctx [ip] : amatc (a),
        amattruncr (a, ip)
    )
);

mode_declare (function (aelim), fixnum);

aelim2 (a, w, ctx) := (
    mode_declare (completearray (ctx), fixnum),
    block (
        [l, jp, p, q, x, y, g, u, v],
        mode_declare (jp, fixnum),
        l : 1,
        for ip : amatr (a) - 1 step -1 while ip >= 0 do (
            jp : ctx [ip],
            p : amatget (a, ip, jp),
            l : lcm2 (l, p, w),
            for j : jp while j < amatc (a) do (
                x : amatget (a, ip, j),
                amatset (a, ip, j, ratsimp (x / p))
            ),
            for i : ip - 1 step -1 while i >= 0 do (
                q : amatget (a, i, jp),
                if q # 0 then (
                    for j : jp while j < amatc (a) do (
                        x : amatget (a, ip, j),
                        y : amatget (a, i, j),
                        amatset (a, i, j, ratsimp (- x * q + y))
                    )
                )
            )
        ),
        l
    )
);

asolve1 (a, ctx, s, k, ip1, j1) := (
    mode_declare (completearray (ctx), fixnum),
    mode_declare (k, fixnum, ip1, fixnum, j1, fixnum),
    block (
        [jp1, jp],
        mode_declare (jp1, fixnum, jp, fixnum),
        jp1 : -1,
        for ip : 0 while ip < ip1 do (
            jp : ctx [ip],
            for j : jp1 + 1 while j < jp do
                amatset (s, j, k, 0),
            amatset (s, jp, k, - amatget (a, ip, j1)),
            jp1 : jp
        ),
        for j : jp1 + 1 while j < j1 do
            amatset (s, j, k, 0),
        amatset (s, j1, k, 1),
        for j : j1 + 1 while j < amatc (a) do
            amatset (s, j, k, 0)
    )
);

asolve (a, ctx) := (
    mode_declare (completearray (ctx), fixnum),
    block (
        [s, k, jp1, jp],
        mode_declare (k, fixnum, jp1, fixnum, jp, fixnum),
        s : newamat (amatc (a), amatc (a) - amatr (a)),
        k : 0,
        jp1 : -1,
        for ip : 0 while ip <= amatr (a) do (
            jp : ctx [ip],
            for j : jp1 + 1 while j < jp do (
                asolve1 (a, ctx, s, k, ip, j),
                k : k + 1
            ),
            jp1 : jp
        ),
        s
    )
);
