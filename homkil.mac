/* number of columns of a matrix */
numcol(m) :=
    if length(m) = 0 then 0
        else length(m[1]);

/* flatten matrix into a column vector */
flatmat(m) :=
    block(
        [a],
        a : matrix(),
        for i : 1 thru numcol(m) do
            a : addrow(a, col(m, i)),
        a
    );

/* flatten list of matrices into a matrix */
flatmatls(l) :=
    block(
        [a],
        a : matrix(),
        for i : 1 thru length(l) do
            a : addcol(a, flatmat(l[i])),
        a
    );

/* linear combination given by a column vector */
collincomb(c, b) :=
    block(
        [a],
        a : 0,
        for i : 1 thru length(b) do
            a : a + c[i][1] * b[i],
        a
    );

/* least-square solution of m . x = y */
lssolve(m) :=
    block(
        [mct],
        mct : conjugate(transpose(m)),
        ((mct . m)^^-1) . mct
    );

/* adjoint representation of a matrix Lie algebra */
adjrep(l) :=
    block(
        [n, lss, a, aa, x, y, c],
        n : length(l),
        lss : lssolve(flatmatls(l)),
        a : [],
        for i : 1 thru n do (
            x : l[i],
            aa : matrix(),
            for j : 1 thru n do (
                y : l[j],
                c : x . y - y . x,
                aa : addcol(aa, lss . flatmat(c))
            ),
            a : endcons(aa, a)
        ),
        a
    );

/* "curvature" of a Lie algebra map, i.e. matrices
   r(x) . r(y) - r(y) . r(x) - r(ad(x)(y)) */
lacurv(r, ad) :=
    block(
        [n, a, aa, rx, ry, adx, c1, c2],
        n : length(r),
        a : matrix(),
        for i : 1 thru n do (
            rx : r[i],
            adx : ad[i],
            aa : [],
            for j : 1 thru n do (
                ry : r[j],
                c1 : rx . ry - ry . rx,
                c2 : collincomb(col(adx, j), r),
                aa : endcons(c1 - c2, aa)
            ),
            a : addrow(a, aa)
        ),
        a
    );

/* check Lie algebra structure */
checkla(l, ad) :=
    block(
        [c],
        c : lacurv(l, ad),
        if zeromatrixp(c) then return(true),
        print(box("Not a Lie algebra, obstruction:")),
        print(c),
        false
    );

/* inject vector into affine LA */
iv2aff(v) :=
    block(
        [n],
        n : length(v),
        addrow(
            zeromatrix(1, n + 1),
            addcol(v, zeromatrix(n, n))
        )
    );

/* inject linear map into affine LA */
im2aff(m) :=
    block(
        [nr, nc],
        nr : length(m),
        nc : numcol(m),
        addrow(
            zeromatrix(1, nc + 1),
            addcol(zeromatrix(nr, 1), m)
        )
    );

/* project affine LA onto vector */
paff2v(a) :=
    col(submatrix(1, a), 1);

matpaff2v(m) :=
    matrixmap(paff2v, m);

/* project affine LA onto linear map */
paff2m(a) :=
    submatrix(1, a, 1);

matpaff2m(m) :=
    matrixmap(paff2m, m);

/* decompose matrix to 2 blocks horizontally */
blockmat2h(m, nc) :=
    block(
        [a, b],
        a : matrix(),
        b : matrix(),
        for i : 1 thru numcol(m) do
            if i <= nc
                then a : addcol(a, col(m, i))
                else b : addcol(b, col(m, i)),
        matrix([a, b])
    );

/* decompose matrix to 2 blocks vertically */
blockmat2v(nr, m) :=
    block(
        [a, b],
        a : matrix(),
        b : matrix(),
        for i : 1 thru length(m) do
            if i <= nr
                then a : addrow(a, row(m, i))
                else b : addrow(b, row(m, i)),
        matrix([a], [b])
    );

/* decompose matrix to four blocks */
blockmat4(nr, m, nc) :=
    block(
        [mv],
        mv : blockmat2v(nr, m),
        addrow(
            blockmat2h(mv[1][1], nc),
            blockmat2h(mv[2][1], nc)
        )
    );

/* map reductive LA pair g = V + h to the
   corresponding affine LA m = R^n + gl(n);
   V = span(first n basis elements)
   h = span(rest of basis elements) */
la2aff(ad, n) :=
    block(
        [idn, a, r],
        r : [],
        /* V maps to R^n simply by coordinates */
        idn : ident(n),
        for i : 1 thru n do (
            a : col(idn, i),
            r : endcons(iv2aff(a), r)
        ),
        /* h maps to gl(n) by ad restricted to V */
        for i : n + 1 thru length(ad) do (
            a : blockmat4(n, ad[i], n)[1][1],
            r : endcons(im2aff(a), r)
        ),
        r
    );

/* Levi-Civita connection from torsion */
lcconn1(t, g, i, j) :=
    block(
        [gi, tj],
        gi : g[i],
        tj : apply(addcol, t[j]),
        transpose(gi . tj . (g^^-1))
    );

lcconn(t, g) :=
    block(
        [n, a, aa, c, tij, gtij, gtji],
        n : length(t),
        a : [],
        for i : 1 thru n do (
            aa : matrix(),
            for j : 1 thru n do (
                tij : t[i][j],
                gtij : lcconn1(t, g, i, j),
                gtji : lcconn1(t, g, j, i),
                c : (gtij + gtji - tij) / 2,
                aa : addcol(aa, c)
            ),
            a : endcons(aa, a)
        ),
        a
    );

/* add linear connection to an affine connection */
affconnadd(ac, lc) :=
    block(
        [n1, a, m],
        n1 : length(ac),
        n2 : length(lc),
        a : [],
        for i : 1 thru n2 do (
            m : ac[i] + im2aff(lc[i]),
            a : endcons(m, a)
        ),
        for i : n2 + 1 thru n1 do
            a : endcons(ac[i], a),
        a
    );

/* check affine structure (= reductive pair) */
checkaffcurv(blcurv) :=
    block(
        [c0],
        c0 : matrix(
            [zerofor(blcurv[1][1]),
                blcurv[1][2]],
            [blcurv[2][1],
                blcurv[2][2]]
        ),
        if zeromatrixp(c0) then return(true),
        print(box("Not an affine structure, obstruction:")),
        print(c0),
        false
    );

/* check Levi-Civita connection (= torsion free) */
checklctors(tors) :=
    block(
        if zeromatrixp(tors) then return(true),
        print(box("Not a Levi-Civita connection, torsion:")),
        print(tors),
        false
    );

/* prepare Riemannian homogeneous space from [l, g];
   l = basis of a LA split to V + h
   g = metric on V

   returns [ad, lc, curv];
   ad = adjoint representation of l
   lc = Levi-Civita connection
   curv = curvature of lc */
riemhom(l, g) :=
    block(
        [n, ad, aff, blcurv, acurv, tors, lc, curv],
        n : length(g),
        ad : adjrep(l),
        if not checkla(l, ad) then return(false),
        aff : la2aff(ad, n),
        blcurv : blockmat4(n, lacurv(aff, ad), n),
        if not checkaffcurv(blcurv) then return(false),
        acurv : blcurv[1][1],
        tors : matpaff2v(acurv),
        lc : lcconn(tors, g),
        aff : affconnadd(aff, lc),
        blcurv : blockmat4(n, lacurv(aff, ad), n),
        acurv : blcurv[1][1],
        tors : matpaff2v(acurv),
        if not checklctors(tors) then return(false),
        curv : matpaff2m(acurv),
        [ad, lc, curv]
    );
