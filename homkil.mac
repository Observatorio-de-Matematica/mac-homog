/* number of columns of a matrix */
numcol(m) :=
    if length(m) = 0 then 0
        else length(m[1]);

/* flatten matrix into a column vector */
flatmat(m) :=
    block(
        [a],
        a : matrix(),
        for i : 1 thru numcol(m) do
            a : addrow(a, col(m, i)),
        a
    );

/* flatten list of matrices into a matrix */
flatmatls(l) :=
    block(
        [a],
        a : matrix(),
        for i : 1 thru length(l) do
            a : addcol(a, flatmat(l[i])),
        a
    );

/* linear combination given by a column vector */
collincomb(c, b) :=
    block(
        [a],
        a : 0,
        for i : 1 thru length(b) do
            a : a + c[i][1] * b[i],
        a
    );

/* least-square solution of m . x = y */
lssolve(m) :=
    block(
        [mct],
        mct : conjugate(transpose(m)),
        ((mct . m)^^-1) . mct
    );

/* adjoint representation of a matrix Lie algebra */
adjrep(l) :=
    block(
        [n, lss, a, aa, x, y, c],
        n : length(l),
        lss : lssolve(flatmatls(l)),
        a : [],
        for i : 1 thru n do (
            x : l[i],
            aa : matrix(),
            for j : 1 thru n do (
                y : l[j],
                c : x . y - y . x,
                aa : addcol(aa, lss . flatmat(c))
            ),
            a : endcons(aa, a)
        ),
        a
    );

/* "curvature" of a Lie algebra map, i.e. matrices
   r(x) . r(y) - r(y) . r(x) - r(ad(x)(y)) */
lacurv(r, ad) :=
    block(
        [n, a, aa, rx, ry, adx, c1, c2],
        n : length(r),
        a : matrix(),
        for i : 1 thru n do (
            rx : r[i],
            adx : ad[i],
            aa : [],
            for j : 1 thru n do (
                ry : r[j],
                c1 : rx . ry - ry . rx,
                c2 : collincomb(col(adx, j), r),
                aa : endcons(c1 - c2, aa)
            ),
            a : addrow(a, aa)
        ),
        a
    );

/* check Lie algebra structure */
checkla(l, ad) :=
    block(
        [c],
        c : lacurv(l, ad),
        if zeromatrixp(c) then return(true),
        print(box("Not a Lie algebra, obstruction:")),
        print(c),
        false
    );

/* split list to fist n elements and the rest */
nsplitls(l, n) :=
    block(
        [m],
        m : length(l),
        if m <= n
            then [l, []]
            else [firstn(l, n), lastn(l, m - n)]
    );

/* list of n zero matrices n x n */
zeromatls(n) :=
    makelist(zeromatrix(n, n), n);

/* elementary basis vector, or zero if k > n */
evect(k, n) :=
    if k <= n
        then ematrix(n, 1, 1, k, 1)
        else zeromatrix(n, 1);

/* affine LA matrix from evect and a matrix */
affmat(k, m) :=
    block(
        [nr, nc],
        nr : length(m),
        nc : numcol(m),
        addrow(
            zeromatrix(1, 1 + nc),
            addcol(evect(k, nr), m)
        )
    );

/* list of affine LA matrices */
affmatls(l) :=
    block(
        [a],
        a : [],
        for i : 1 thru length(l) do
            a : endcons(affmat(i, l[i]), a),
        a
    );

/* decompose matrix to 2 blocks horizontally */
blockmat2h(m, nc) :=
    block(
        [a, b],
        a : matrix(),
        b : matrix(),
        for i : 1 thru numcol(m) do
            if i <= nc
                then a : addcol(a, col(m, i))
                else b : addcol(b, col(m, i)),
        matrix([a, b])
    );

/* decompose matrix to 2 blocks vertically */
blockmat2v(nr, m) :=
    block(
        [a, b],
        a : matrix(),
        b : matrix(),
        for i : 1 thru length(m) do
            if i <= nr
                then a : addrow(a, row(m, i))
                else b : addrow(b, row(m, i)),
        matrix([a], [b])
    );

/* decompose matrix to four blocks */
blockmat4(nr, m, nc) :=
    block(
        [mv],
        mv : blockmat2v(nr, m),
        addrow(
            blockmat2h(mv[1][1], nc),
            blockmat2h(mv[2][1], nc)
        )
    );

/* decompose list of matrices to four blocks */
blockmat4ls(nr, l, nc) :=
    block(
        [a11, a12, a21, a22, b],
        a11 : [],
        a12 : [],
        a21 : [],
        a22 : [],
        for i : 1 thru length(l) do (
            b : blockmat4(nr, l[i], nc),
            a11 : endcons(b[1][1], a11),
            a12 : endcons(b[1][2], a12),
            a21 : endcons(b[2][1], a21),
            a22 : endcons(b[2][2], a22)
        ),
        matrix([a11, a12], [a21, a22])
    );

/* decompose matrix of matrices to four blocks */
blockmat4mat(nr, m, nc) :=
    block(
        [a11, a12, a21, a22, bl],
        a11 : matrix(),
        a12 : matrix(),
        a21 : matrix(),
        a22 : matrix(),
        for i : 1 thru length(m) do (
            bl : blockmat4ls(nr, m[i], nc),
            a11 : addrow(a11, bl[1][1]),
            a12 : addrow(a12, bl[1][2]),
            a21 : addrow(a21, bl[2][1]),
            a22 : addrow(a22, bl[2][2])
        ),
        matrix([a11, a12], [a21, a22])
    );

/* Levi-Civita connection from torsion */
lcconn1(t, g, i, j) :=
    block(
        [gi, tj],
        gi : g[i],
        tj : apply(addcol, t[j]),
        transpose(gi . tj . (g^^-1))
    );

lcconn(t, g) :=
    block(
        [n, a, aa, c, tij, gtij, gtji],
        n : length(t),
        a : [],
        for i : 1 thru n do (
            aa : matrix(),
            for j : 1 thru n do (
                tij : t[i][j],
                gtij : lcconn1(t, g, i, j),
                gtji : lcconn1(t, g, j, i),
                c : (gtij + gtji - tij) / 2,
                aa : addcol(aa, c)
            ),
            a : endcons(aa, a)
        ),
        a
    );

/* check affine structure (= reductive pair) */
checkaffcurv(blcurv) :=
    block(
        [c0],
        c0 : matrix(
            [zerofor(blcurv[1][1]),
                blcurv[1][2]],
            [blcurv[2][1],
                blcurv[2][2]]
        ),
        if zeromatrixp(c0) then return(true),
        print(box("Not an affine structure, obstruction:")),
        print(c0),
        false
    );

/* apply a representation on a metric (bilinear form) */
repmet(r, g) :=
    block(
        [n, a, c, gc],
        n : length(g),
        a : [],
        for i : 1 thru length(r) do (
            c : blockmat4(n, r[i], n)[1][1],
            gc : transpose(c) . g + g . c,
            a : endcons(gc, a)
        ),
        a    
    );

/* check invariant metric (bilinear form) */
checkinvmet(r, g) :=
    block(
        [rg],
        rg : repmet(r, g),
        if zeromatrixp(rg) then return(true),
        print(box("Not an invariant metric, obstruction:")),
        print(rg),
        false
    );

/* check Levi-Civita connection (= torsion free) */
checklctors(tors) :=
    block(
        if zeromatrixp(tors) then return(true),
        print(box("Not a Levi-Civita connection, torsion:")),
        print(tors),
        false
    );

/* prepare Riemannian homogeneous space from [l, g];
   l = basis of a LA split to V + h
   g = metric on V

   returns [ad, lc, curv];
   ad = adjoint representation of l
   lc = Levi-Civita connection
   curv = curvature of lc */
riemhom(l, g) :=
    block(
        [n, ad, adspl, hc, aff, blcurv, acurv, tors, lc],
        n : length(g),
        ad : adjrep(l),
        if not checkla(l, ad) then return(false),
        adspl : nsplitls(ad, n),
        hc : blockmat4ls(n, adspl[2], n)[1][1],
        if not checkinvmet(hc, g) then return(false),
        aff : affmatls(append(zeromatls(n), hc)),
        blcurv : blockmat4(n, lacurv(aff, ad), n),
        if not checkaffcurv(blcurv) then return(false),
        acurv : blockmat4mat(1, blcurv[1][1], 1),
        tors : acurv[2][1],
        lc : append(lcconn(tors, g), hc),
        aff : affmatls(lc),
        blcurv : blockmat4(n, lacurv(aff, ad), n),
        acurv : blockmat4mat(1, blcurv[1][1], 1),
        tors : acurv[2][1],
        if not checklctors(tors) then return(false),
        curv : acurv[2][2],
        [ad, lc, curv]
    );

/* dual, i.e. negative transpose of a matrix */
dualrep(m) :=
    - transpose(m);

/* dual LA representation */
dualrepls(l) :=
    map(dualrep, l);

/* elementary unitary matrix */
eumat(n, x, i, j) :=
    block(
        [em],
        em : ematrix(n, n, x, i, j),
        if i = j then em : em / 2,
        em - conjugate(transpose(em))
    );

/* unitary LA */
ula(n) :=
    block(
        [a],
        a : [],
        for i : 1 thru n do (
            a : endcons(eumat(n, %i, i, i), a),
            for j : i + 1 thru n do (
                a : endcons(eumat(n, 1, j, i), a),
                a : endcons(eumat(n, %i, j, i), a)
            )
        ),
        a
    );

/* Berger sphere */
bergs(m) :=
    block(
        [l, n, g],
        l : ula(m),
        n : 2 * m - 1,
        g : ident(n) + ematrix(n, n, s - 1, 1, 1),
        ratsimp(riemhom(l, g))
    );
